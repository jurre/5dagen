THERE_BE_DRAGONS_HERE
Deprecation: The method SequenceableCollection sortBy: has been deprecated.
use #sort: or #sorted: instead
29 June 2011 4:02:39 pm

VM: Mac OS - intel - 1067 - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51] Seaside 3.0
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /Users/diegolont/Documents/Delware/Promotie/summerschool/Seaside.app/Contents/Resources
Trusted Dir /foobar/tooBar/forSqueak/bogus
Untrusted Dir /Users/diegolont/Library/Preferences/Squeak/Internet/My Squeak

OrderedCollection(Object)>>deprecated:on:in:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		anExplanationString: 	'use #sort: or #sorted: instead'
		date: 	'04 September 2010'
		version: 	'Pharo1.2'
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	2


OrderedCollection(SequenceableCollection)>>sortBy:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aBlock: 	[:a :b | a voteValue > b voteValue]
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	2


FOHome>>renderQuestionsOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


[self renderQuestionsOn: canvas] in FOHome>>renderContentOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


BlockClosure>>renderOn:
	Receiver: [self renderQuestionsOn: canvas]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOHome>>renderContentOn:
		startpc: 	44
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'homepage')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'homepage')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderQuestionsOn: canvas]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'homepage')


FOHome>>renderContentOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOHome
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOHome
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOHome
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOHome(WAComponent)>>accept:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOHome
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOHome(WAComponent)>>accept:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOHome(WAComponent)>>acceptDecorated:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOHome
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOHome(WAPainter)>>renderWithContext:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


FOHome(WAPainter)>>renderOn:
	Receiver: a FOHome
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOHome


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOHome
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOHome
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOHome
		homepage: 	nil
		loginName: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
OrderedCollection(Object)>>deprecated:on:in:
OrderedCollection(SequenceableCollection)>>sortBy:
FOHome>>renderQuestionsOn:
[self renderQuestionsOn: canvas] in FOHome>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOHome>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOHome(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOHome(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOHome(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOHome(WAPainter)>>renderWithContext:
FOHome(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>captureAndInvoke
WARenderLoopMain>>start
FOSession(WASession)>>start
[^ self start] in FOSession(WASession)>>handleFiltered:
WAMergedRequestFields>>at:ifAbsent:
FOSession(WASession)>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handle:registering:
WAApplication>>handleDefault:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAgileOverflow>>logout
4 July 2011 11:24:01 am

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAgileOverflow(Object)>>doesNotUnderstand: #logout
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		aMessage: 	logout
		exception: 	MessageNotUnderstood: FOAgileOverflow>>logout
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOHome
		homepage: 	nil
		loginName: 	''


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#('Logout')
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
		key: 	'FDiJno-g1EBcUHeG'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	1255526
		previousTiming: 	4


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	1255526
		previousTiming: 	4


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	1255526
		previousTiming: 	4


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=qk2--WHYP-sEY4Fm&_k...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	a FOAuthor
		announcer: 	an Announcer
		local: 	nil



--- The full stack ---
FOAgileOverflow(Object)>>doesNotUnderstand: #logout
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAgileOverflow>>logout
4 July 2011 11:32:50 am

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAgileOverflow(Object)>>doesNotUnderstand: #logout
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		aMessage: 	logout
		exception: 	MessageNotUnderstood: FOAgileOverflow>>logout
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOHome
		homepage: 	nil
		loginName: 	''


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#('Logout')
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
		key: 	'Cd2qAywv1j_Mhz2T'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	86468
		previousTiming: 	18


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	86468
		previousTiming: 	18


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	86468
		previousTiming: 	18


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil



--- The full stack ---
FOAgileOverflow(Object)>>doesNotUnderstand: #logout
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAgileOverflow>>logout
4 July 2011 11:37:23 am

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAgileOverflow(Object)>>doesNotUnderstand: #logout
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		aMessage: 	logout
		exception: 	MessageNotUnderstood: FOAgileOverflow>>logout
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOHome
		homepage: 	nil
		loginName: 	''


GRUnboundDelayedSend>>valueWithArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#()
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


GRUnboundDelayedSend>>valueWithPossibleArguments:
	Receiver: a GRUnboundDelayedSend receiver: a FOAgileOverflow selector: #logout
	Arguments and temporary variables: 
		anArray: 	#('Logout')
	Receiver's instance variables: 
		receiver: 	a FOAgileOverflow
		selector: 	#logout


WAActionCallback>>evaluateWithArgument:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anObject: 	nil
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


WAActionCallback(WACallback)>>evaluateWithFieldValues:
	Receiver: a WAActionCallback
	Arguments and temporary variables: 
		anOrderedCollection: 	#(nil)
	Receiver's instance variables: 
		key: 	'1'
		block: 	[self answer: true]


[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		fields: 	a WAActionCallback
		callback: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


Array(SequenceableCollection)>>do:
	Receiver: an Array(a WAActionCallback)
	Arguments and temporary variables: 
		aBlock: 	[:callback | callback
		evaluateWithFieldValues: (fields allAt: callbac...etc...
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a WAActionCallback)

WACallbackRegistry>>handle:
	Receiver: a WACallbackRegistry
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
		set: 	a Set(a WAActionCallback)
		fields: 	a WAMergedRequestFields
	Receiver's instance variables: 
		callbacks: 	a Dictionary('1'->a WAActionCallback '10'->a WAActionCallback '11'->...etc...
		nextKey: 	26


[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self renderContext callbacks handle: self requestContext]
	Arguments and temporary variables: 
		exception: 	WARenderNotification
		handlerAction: 	[:n | nil]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[self
		withNotificationHandlerDo: [self renderContext callbacks ...etc...
		startpc: 	78
		numArgs: 	0


WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self renderContext callbacks handle: self requestContext]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>ensure:
	Receiver: [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestConte...etc...
	Arguments and temporary variables: 
		aBlock: 	[self request isXmlHttpRequest
		ifTrue: [self captureState]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation>>runCallbacks
		startpc: 	73
		numArgs: 	0


WAActionPhaseContinuation>>runCallbacks
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation>>handleRequest
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


BlockClosure>>on:do:
	Receiver: [self handleRequest]
	Arguments and temporary variables: 
		exception: 	WAUnregisteredHandlerError
		handlerAction: 	[:err | self requestContext redirectTo: self application url]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WAActionPhaseContinuation(WASessionContinuation)>>basicValue
		startpc: 	26
		numArgs: 	0


WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 
		aBlock: 	[self handleRequest]
	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>basicValue
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


WAActionPhaseContinuation(WASessionContinuation)>>value
	Receiver: a WAActionPhaseContinuation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		states: 	a WASnapshot
		renderContext: 	a WARenderContext


FOSession(WASession)>>handleFiltered:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
		key: 	'Cd2qAywv1j_Mhz2T'
		continuation: 	a WAActionPhaseContinuation
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil


WATimingToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	358928
		previousTiming: 	272458


[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	358928
		previousTiming: 	272458


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[previousTiming := self currentTiming]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WATimingToolFilter>>handleFiltered:
		startpc: 	41
		numArgs: 	0


WATimingToolFilter>>handleFiltered:
	Receiver: a WATimingToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a FOSession
		startTime: 	358928
		previousTiming: 	272458


WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		exception: 	GRDeprecatedApiNotification
		handlerAction: 	[:notification | self deprecated: notification]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	WADeprecatedToolFilter>>handleFiltered:
		startpc: 	34
		numArgs: 	0


WADeprecatedToolFilter>>handleFiltered:
	Receiver: a WADeprecatedToolFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WATimingToolFilter
		notifications: 	an OrderedCollection()


WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


BlockClosure>>ensure:
	Receiver: [super handleFiltered: aRequestContext]
	Arguments and temporary variables: 
		aBlock: 	[owner := nil]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WAMutualExclusionFilter>>handleFiltered:
		startpc: 	44
		numArgs: 	0


[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore(a Process in [caught := true.
	self wait.
	blockValue :=...etc...
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
	Receiver: a Semaphore(a Process in [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	a Process in [caught := true.
	self wait.
	blockValue := mutuallyExc...etc...
		lastLink: 	a Process in [caught := true.
	self wait.
	blockValue := mutuallyExcl...etc...
		excessSignals: 	0


BlockClosure>>ensure:
	Receiver: [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value]
	Arguments and temporary variables: 
		aBlock: 	[caught
		ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	38
		numArgs: 	0


Semaphore>>critical:
	Receiver: a Semaphore(a Process in [caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		firstLink: 	a Process in [caught := true.
	self wait.
	blockValue := mutuallyExc...etc...
		lastLink: 	a Process in [caught := true.
	self wait.
	blockValue := mutuallyExcl...etc...
		excessSignals: 	0


WAMutex>>critical:
	Receiver: a WAMutex
	Arguments and temporary variables: 
		aBlock: 	[super handleFiltered: aRequestContext]
		process: 	a Process in GRPharoPlatform>>openDebuggerOn:
	Receiver's instance variables: 
		semaphore: 	a Semaphore(a Process in [caught := true.
	self wait.
	blockValue :=...etc...
		owner: 	a Process in GRPharoPlatform>>openDebuggerOn:


WAMutualExclusionFilter>>handleFiltered:
	Receiver: a WAMutualExclusionFilter
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		next: 	a WAValueHolder contents: a WADeprecatedToolFilter
		mutex: 	a WAMutex


[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
	Receiver: a FOSession
	Arguments and temporary variables: 
		aRequestContext: 	a WARequestContext url: '/AgileOverflow?_s=NOcKxrwHJ4NGEG18&_k...etc...
	Receiver's instance variables: 
		filter: 	a WAValueHolder contents: a WAMutualExclusionFilter
		parent: 	a WAApplication
		configuration: 	a WAUserConfiguration
		continuations: 	a WACache
		properties: 	a GRSmallDictionary(#presenter->a FOAgileOverflow)
		jumpTo: 	nil
		user: 	nil
		announcer: 	an Announcer
		local: 	nil



--- The full stack ---
FOAgileOverflow(Object)>>doesNotUnderstand: #logout
GRUnboundDelayedSend>>valueWithArguments:
GRUnboundDelayedSend>>valueWithPossibleArguments:
WAActionCallback>>evaluateWithArgument:
WAActionCallback(WACallback)>>evaluateWithFieldValues:
[:callback | callback
		evaluateWithFieldValues: (fields allAt: callback key)] in WACallbackRegistry>>handle:
Array(SequenceableCollection)>>do:
WACallbackRegistry>>handle:
[self renderContext callbacks handle: self requestContext] in [self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>on:do:
WAActionPhaseContinuation(WARenderLoopContinuation)>>withNotificationHandlerDo:
[self
		withNotificationHandlerDo: [self renderContext callbacks handle: self requestContext].
	(WAVisiblePresenterGuide client: WATaskVisitor new)
		start: self presenter] in WAActionPhaseContinuation>>runCallbacks
BlockClosure>>ensure:
WAActionPhaseContinuation>>runCallbacks
WAActionPhaseContinuation>>handleRequest
[self handleRequest] in WAActionPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WAActionPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WAActionPhaseContinuation(WASessionContinuation)>>basicValue
WAActionPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:00:43 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233641
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233641
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233641
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233641
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233641
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487233641
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[845@260 mouseUp 1759692 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [845@260 mouseUp 1759692 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	1759692
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	845@260
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[845@260 mouseUp 1759692 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	845@261 corner: 861@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	845@261 corner: 861@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(498073600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[845@260 845@261 mouseMove 1759712 nil]
		targetOffset: 	114@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 1759712 845 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(495452160) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[845@260 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(495452160) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	845@261 corner: 861@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	845@261 corner: 861@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(498073600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[845@260 845@261 mouseMove 1759712 nil]
		targetOffset: 	114@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 1759712 845 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	845@261 corner: 861@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	845@261 corner: 861@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(498073600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[845@260 845@261 mouseMove 1759712 nil]
		targetOffset: 	114@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 1759712 845 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
	Receiver's instance variables: 
		bounds: 	845@261 corner: 861@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	845@261 corner: 861@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(498073600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[845@260 845@261 mouseMove 1759712 nil]
		targetOffset: 	114@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 1759712 845 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[845@260 mouseUp 1759692 nil]
		evt: 	[845@260 mouseUp 1759692 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	845@261 corner: 861@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	845@261 corner: 861@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(498073600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[845@260 845@261 mouseMove 1759712 nil]
		targetOffset: 	114@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 1759712 845 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[845@260 mouseUp 1759692 nil]
		evtBuf: 	#(1 1759692 845 260 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	845@261 corner: 861@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	845@261 corner: 861@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(498073600)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[845@260 845@261 mouseMove 1759712 nil]
		targetOffset: 	114@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 1759712 845 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(737148928))(an Ove...etc...
		lastStepTime: 	1759688
		lastStepMessage: 	nil
		lastCycleTime: 	1759730
		alarms: 	a Heap()
		lastAlarmTime: 	1759688
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt: 
4 July 2011 12:22:16 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOPost(Object)>>halt
	Receiver: a FOPost
	Arguments and temporary variables: 

	Receiver's instance variables: 
		author: 	nil
		votes: 	nil
		content: 	nil


FOPost>>voteUp:
	Receiver: a FOPost
	Arguments and temporary variables: 
		anAuthor: 	nil
	Receiver's instance variables: 
		author: 	nil
		votes: 	nil
		content: 	nil


TestPost>>testAuthorCannotVoteOwnPost
	Receiver: TestPost>>#testAuthorCannotVoteOwnPost
	Arguments and temporary variables: 
		post: 	a FOPost
		author: 	nil
	Receiver's instance variables: 
		testSelector: 	#testAuthorCannotVoteOwnPost


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testAuthorCannotVoteOwnPost
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAuthorCannotVoteOwnPost


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testAuthorCannotVoteOwnPost
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAuthorCannotVoteOwnPost


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testAuthorCannotVoteOwnPost
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testAuthorCannotVoteOwnPost


[aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase announce: TestCaseEnded withResult: self.
	self addPass: aTestCase] in TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testAuthorCannotVoteOwnPost
	Receiver's instance variables: 
		timeStamp: 	2011-07-04T12:22:16+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase anno...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	58
		numArgs: 	0


TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testAuthorCannotVoteOwnPost
	Receiver's instance variables: 
		timeStamp: 	2011-07-04T12:22:16+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()


TestPost(TestCase)>>run:
	Receiver: TestPost>>#testAuthorCannotVoteOwnPost
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpect...etc...
	Receiver's instance variables: 
		testSelector: 	#testAuthorCannotVoteOwnPost


TestRunner>>runTest:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testAuthorCannotVoteOwnPost
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234936
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


[:each | self runTest: each] in TestRunner>>runSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testAuthorCannotVoteOwnPost
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234936
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


[:each | 
| newLabel |
(count = 0
			or: [count + 1 = size
					or: [(Time millisecondsSince: lastUpdate)
							>= msecs]])
		ifTrue: [bar value: count.
			oldLabel = (newLabel := (labelBlock value: each)
								ifNil: [oldLabel])
				ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
			lastUpdate := Time millisecondClockValue].
	aBlock value: each.
	count := count + 1] in [:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | 
| newLabel |
(count = 0
			or: [count + 1 = size
					or: [(T...etc...
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


[result := workBlock value: progress] in [[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		progress: 	[:barValArg | 
| barVal return newBarSize |
barVal := barValArg.
	ret...etc...
		result: 	#(nil)
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


BlockClosure>>on:do:
	Receiver: [result := workBlock value: progress]
	Arguments and temporary variables: 
		exception: 	ProgressNotification
		handlerAction: 	[:ex | 
ex extraParam isString
		ifTrue: [SystemProgressMorph un...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[[result := workBlock value: progress]
		on: ProgressNotification...etc...
		startpc: 	83
		numArgs: 	0


[[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		progress: 	[:barValArg | 
| barVal return newBarSize |
barVal := barValArg.
	ret...etc...
		result: 	#(nil)
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


BlockClosure>>ensure:
	Receiver: [[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[SystemProgressMorph close: progress]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ProgressInitiationException>>defaultMorphicAction
		startpc: 	77
		numArgs: 	0


ProgressInitiationException>>defaultMorphicAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		progress: 	[:barValArg | 
| barVal return newBarSize |
barVal := barValArg.
	ret...etc...
		result: 	#(nil)
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


MorphicUIManager>>progressInitiationExceptionDefaultAction:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		anException: 	ProgressInitiationException: 
	Receiver's instance variables: 
		interactiveParser: 	nil


ProgressInitiationException>>defaultAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	ProgressInitiationException: 
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ProgressInitiationException: 
		val: 	nil
	Receiver's instance variables: 
		sender: 	PasteUpMorph>>becomeActiveDuring:
		pc: 	17
		stackp: 	3
		method: 	(BlockClosure>>#on:do: "a CompiledMethod(88866816)")
		closureOrNil: 	nil
		receiver: 	[aBlock value]


ProgressInitiationException(Exception)>>signal
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


ProgressInitiationException>>display:at:from:to:during:
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		argString: 	''
		argPoint: 	353@647
		argMinVal: 	0
		argMaxVal: 	8
		argWorkBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					o...etc...
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


ProgressInitiationException class>>display:at:from:to:during:
	Receiver: ProgressInitiationException
	Arguments and temporary variables: 
		aString: 	''
		aPoint: 	353@647
		minVal: 	0
		maxVal: 	8
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->(ProgressInitiationException>>#d...etc...
		format: 	150
		instanceVariables: 	#('workBlock' 'maxVal' 'minVal' 'aPoint' 'progressTitle')
		organization: 	('*Morphic' defaultMorphicAction)
('accessing' maxVal minVal poin...etc...
		subclasses: 	nil
		name: 	#ProgressInitiationException
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'UIManager-Support'
		traitComposition: 	{}
		localSelectors: 	nil


ByteString(String)>>displayProgressAt:from:to:during:
	Receiver: ''
	Arguments and temporary variables: 
		aPoint: 	353@647
		minVal: 	0
		maxVal: 	8
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
	Receiver's instance variables: 
''

OrderedCollection(Collection)>>do:displayingProgress:every:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


OrderedCollection(Collection)>>do:displayingProgress:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTest: each]
		aStringOrBlock: 	'Running 8 Tests'
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | self runTest: each]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234936
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | self runTest: each]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234936
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>runSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234936
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>runAll
	Receiver: a TestRunner
	Arguments and temporary variables: 

	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234936
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableButtonMorph>>performAction
	Receiver: a PluggableButtonMorph(844890112)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	297@626 corner: 442@667
		owner: 	a PluggableThemedOverflowPanelMorph(813170688)
		submorphs: 	an Array(an AlignmentMorph(468713472))
		fullBounds: 	297@626 corner: 442@667
		color: 	Color transparent
		extension: 	a MorphExtension (851443712) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a TestRunner
		label: 	'Run Selected'
		getStateSelector: 	nil
		actionSelector: 	#runAll
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#hasRunnable


[:m | (m containsPoint: evt cursorPoint)
		ifTrue: [m enabled
				ifTrue: [m performAction]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(844890112)
	Arguments and temporary variables: 
		evt: 	a PluggableButtonMorph(844890112)
		m: 	[353@647 mouseUp 3051912 nil]
	Receiver's instance variables: 
		bounds: 	297@626 corner: 442@667
		owner: 	a PluggableThemedOverflowPanelMorph(813170688)
		submorphs: 	an Array(an AlignmentMorph(468713472))
		fullBounds: 	297@626 corner: 442@667
		color: 	Color transparent
		extension: 	a MorphExtension (851443712) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a TestRunner
		label: 	'Run Selected'
		getStateSelector: 	nil
		actionSelector: 	#runAll
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#hasRunnable


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(844890112) a PluggableButtonMorph(730595328) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m | (m containsPoint: evt cursorPoint)
		ifTrue: [m enabled
				ifTru...etc...
		index: 	1
		indexLimiT: 	6
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(844890112) a PluggableButtonMorph(730595328) a PluggableBu...etc...


--- The full stack ---
FOPost(Object)>>halt
FOPost>>voteUp:
TestPost>>testAuthorCannotVoteOwnPost
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase announce: TestCaseEnded withResult: self.
	self addPass: aTestCase] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
TestPost(TestCase)>>run:
TestRunner>>runTest:
[:each | self runTest: each] in TestRunner>>runSuite:
[:each | 
| newLabel |
(count = 0
			or: [count + 1 = size
					or: [(Time millisecondsSince: lastUpdate)
							>= msecs]])
		ifTrue: [bar value: count.
			oldLabel = (newLabel := (labelBlock value: each)
								ifNil: [oldLabel])
				ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
			lastUpdate := Time millisecondClockValue].
	aBlock value: each.
	count := count + 1] in [:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection>>do:
[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
[result := workBlock value: progress] in [[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
BlockClosure>>on:do:
[[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
BlockClosure>>ensure:
ProgressInitiationException>>defaultMorphicAction
MorphicUIManager>>progressInitiationExceptionDefaultAction:
ProgressInitiationException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
ProgressInitiationException(Exception)>>signal
ProgressInitiationException>>display:at:from:to:during:
ProgressInitiationException class>>display:at:from:to:during:
ByteString(String)>>displayProgressAt:from:to:during:
OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection(Collection)>>do:displayingProgress:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>runSuite:
TestRunner>>runAll
PluggableButtonMorph>>performAction
[:m | (m containsPoint: evt cursorPoint)
		ifTrue: [m enabled
				ifTrue: [m performAction]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt: 
4 July 2011 12:23:17 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAnswer(Object)>>halt
	Receiver: a FOAnswer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection()
		content: 	nil
		accepted: 	nil


FOAnswer(FOPost)>>voteUp:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection()
		content: 	nil
		accepted: 	nil


TestPost>>testPostVoteSize
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


[aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase announce: TestCaseEnded withResult: self.
	self addPass: aTestCase] in TestResult>>runCase:
	Receiver: 5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteSize
	Receiver's instance variables: 
		timeStamp: 	2011-07-04T12:22:16+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#...etc...


BlockClosure>>on:do:
	Receiver: [aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase anno...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	58
		numArgs: 	0


TestResult>>runCase:
	Receiver: 5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteSize
	Receiver's instance variables: 
		timeStamp: 	2011-07-04T12:22:16+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#...etc...


TestPost(TestCase)>>run:
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 
		aResult: 	5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpect...etc...
	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


TestRunner>>runTest:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteSize
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234997
		result: 	5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


[:each | self runTest: each] in TestRunner>>runSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVoteSize
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234997
		result: 	5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


[:each | 
| newLabel |
(count = 0
			or: [count + 1 = size
					or: [(Time millisecondsSince: lastUpdate)
							>= msecs]])
		ifTrue: [bar value: count.
			oldLabel = (newLabel := (labelBlock value: each)
								ifNil: [oldLabel])
				ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
			lastUpdate := Time millisecondClockValue].
	aBlock value: each.
	count := count + 1] in [:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | 
| newLabel |
(count = 0
			or: [count + 1 = size
					or: [(T...etc...
		index: 	8
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


[result := workBlock value: progress] in [[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		progress: 	[:barValArg | 
| barVal return newBarSize |
barVal := barValArg.
	ret...etc...
		result: 	#(nil)
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


BlockClosure>>on:do:
	Receiver: [result := workBlock value: progress]
	Arguments and temporary variables: 
		exception: 	ProgressNotification
		handlerAction: 	[:ex | 
ex extraParam isString
		ifTrue: [SystemProgressMorph un...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	[[result := workBlock value: progress]
		on: ProgressNotification...etc...
		startpc: 	83
		numArgs: 	0


[[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		progress: 	[:barValArg | 
| barVal return newBarSize |
barVal := barValArg.
	ret...etc...
		result: 	#(nil)
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


BlockClosure>>ensure:
	Receiver: [[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extr...etc...
	Arguments and temporary variables: 
		aBlock: 	[SystemProgressMorph close: progress]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ProgressInitiationException>>defaultMorphicAction
		startpc: 	77
		numArgs: 	0


ProgressInitiationException>>defaultMorphicAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		progress: 	[:barValArg | 
| barVal return newBarSize |
barVal := barValArg.
	ret...etc...
		result: 	#(nil)
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


MorphicUIManager>>progressInitiationExceptionDefaultAction:
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
		anException: 	ProgressInitiationException: 
	Receiver's instance variables: 
		interactiveParser: 	nil


ProgressInitiationException>>defaultAction
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	ProgressInitiationException: 
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	ProgressInitiationException: 
		val: 	nil
	Receiver's instance variables: 
		sender: 	PasteUpMorph>>becomeActiveDuring:
		pc: 	17
		stackp: 	3
		method: 	(BlockClosure>>#on:do: "a CompiledMethod(88866816)")
		closureOrNil: 	nil
		receiver: 	[aBlock value]


ProgressInitiationException(Exception)>>signal
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


ProgressInitiationException>>display:at:from:to:during:
	Receiver: ProgressInitiationException: 
	Arguments and temporary variables: 
		argString: 	''
		argPoint: 	353@647
		argMinVal: 	0
		argMaxVal: 	8
		argWorkBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					o...etc...
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	ProgressInitiationException(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
		maxVal: 	8
		minVal: 	0
		aPoint: 	353@647
		progressTitle: 	''


ProgressInitiationException class>>display:at:from:to:during:
	Receiver: ProgressInitiationException
	Arguments and temporary variables: 
		aString: 	''
		aPoint: 	353@647
		minVal: 	0
		maxVal: 	8
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
	Receiver's instance variables: 
		superclass: 	Exception
		methodDict: 	a MethodDictionary(#defaultAction->(ProgressInitiationException>>#d...etc...
		format: 	150
		instanceVariables: 	#('workBlock' 'maxVal' 'minVal' 'aPoint' 'progressTitle')
		organization: 	('*Morphic' defaultMorphicAction)
('accessing' maxVal minVal poin...etc...
		subclasses: 	nil
		name: 	#ProgressInitiationException
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'UIManager-Support'
		traitComposition: 	{}
		localSelectors: 	nil


ByteString(String)>>displayProgressAt:from:to:during:
	Receiver: ''
	Arguments and temporary variables: 
		aPoint: 	353@647
		minVal: 	0
		maxVal: 	8
		workBlock: 	[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: ...etc...
	Receiver's instance variables: 
''

OrderedCollection(Collection)>>do:displayingProgress:every:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


OrderedCollection(Collection)>>do:displayingProgress:
	Receiver: an OrderedCollection(TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testPostHasContent ...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTest: each]
		aStringOrBlock: 	'Running 8 Tests'
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testAuthorCannotVoteOwnPost TestPost>>#testP...etc...
		firstIndex: 	3
		lastIndex: 	10


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | self runTest: each]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234997
		result: 	5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | self runTest: each]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234997
		result: 	5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>runSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234997
		result: 	5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>runAll
	Receiver: a TestRunner
	Arguments and temporary variables: 

	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487234997
		result: 	5 run, 5 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableButtonMorph>>performAction
	Receiver: a PluggableButtonMorph(844890112)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	297@626 corner: 442@667
		owner: 	a PluggableThemedOverflowPanelMorph(813170688)
		submorphs: 	an Array(an AlignmentMorph(468713472))
		fullBounds: 	297@626 corner: 442@667
		color: 	Color transparent
		extension: 	a MorphExtension (851443712) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a TestRunner
		label: 	'Run Selected'
		getStateSelector: 	nil
		actionSelector: 	#runAll
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#hasRunnable


[:m | (m containsPoint: evt cursorPoint)
		ifTrue: [m enabled
				ifTrue: [m performAction]]] in PluggableButtonMorph>>mouseUp:
	Receiver: a PluggableButtonMorph(844890112)
	Arguments and temporary variables: 
		evt: 	a PluggableButtonMorph(844890112)
		m: 	[353@647 mouseUp 3051912 nil]
	Receiver's instance variables: 
		bounds: 	297@626 corner: 442@667
		owner: 	a PluggableThemedOverflowPanelMorph(813170688)
		submorphs: 	an Array(an AlignmentMorph(468713472))
		fullBounds: 	297@626 corner: 442@667
		color: 	Color transparent
		extension: 	a MorphExtension (851443712) [balloonText]  [other:  (lastState -> f...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a TestRunner
		label: 	'Run Selected'
		getStateSelector: 	nil
		actionSelector: 	#runAll
		getLabelSelector: 	nil
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		gradientLook: 	true
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	#hasRunnable


Array(SequenceableCollection)>>do:
	Receiver: an Array(a PluggableButtonMorph(844890112) a PluggableButtonMorph(730595328) a PluggableBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m | (m containsPoint: evt cursorPoint)
		ifTrue: [m enabled
				ifTru...etc...
		index: 	1
		indexLimiT: 	6
	Receiver's instance variables: 
an Array(a PluggableButtonMorph(844890112) a PluggableButtonMorph(730595328) a PluggableBu...etc...


--- The full stack ---
FOAnswer(Object)>>halt
FOAnswer(FOPost)>>voteUp:
TestPost>>testPostVoteSize
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase announce: TestCaseEnded withResult: self.
	self addPass: aTestCase] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
TestPost(TestCase)>>run:
TestRunner>>runTest:
[:each | self runTest: each] in TestRunner>>runSuite:
[:each | 
| newLabel |
(count = 0
			or: [count + 1 = size
					or: [(Time millisecondsSince: lastUpdate)
							>= msecs]])
		ifTrue: [bar value: count.
			oldLabel = (newLabel := (labelBlock value: each)
								ifNil: [oldLabel])
				ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
			lastUpdate := Time millisecondClockValue].
	aBlock value: each.
	count := count + 1] in [:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection>>do:
[:bar | self
		do: [:each | 
			| newLabel |
			(count = 0
					or: [count + 1 = size
							or: [(Time millisecondsSince: lastUpdate)
									>= msecs]])
				ifTrue: [bar value: count.
					oldLabel = (newLabel := (labelBlock value: each)
										ifNil: [oldLabel])
						ifFalse: [ProgressNotification signal: '' extra: (oldLabel := newLabel)].
					lastUpdate := Time millisecondClockValue].
			aBlock value: each.
			count := count + 1]] in OrderedCollection(Collection)>>do:displayingProgress:every:
[result := workBlock value: progress] in [[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
BlockClosure>>on:do:
[[result := workBlock value: progress]
		on: ProgressNotification
		do: [:ex | 
			ex extraParam isString
				ifTrue: [SystemProgressMorph uniqueInstance labelAt: progress put: ex extraParam].
			ex resume]] in ProgressInitiationException>>defaultMorphicAction
BlockClosure>>ensure:
ProgressInitiationException>>defaultMorphicAction
MorphicUIManager>>progressInitiationExceptionDefaultAction:
ProgressInitiationException>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
ProgressInitiationException(Exception)>>signal
ProgressInitiationException>>display:at:from:to:during:
ProgressInitiationException class>>display:at:from:to:during:
ByteString(String)>>displayProgressAt:from:to:during:
OrderedCollection(Collection)>>do:displayingProgress:every:
OrderedCollection(Collection)>>do:displayingProgress:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>runSuite:
TestRunner>>runAll
PluggableButtonMorph>>performAction
[:m | (m containsPoint: evt cursorPoint)
		ifTrue: [m enabled
				ifTrue: [m performAction]]] in PluggableButtonMorph>>mouseUp:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
PluggableButtonMorph>>mouseUp:
PluggableButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableButtonMorph(Morph)>>handleEvent:
PluggableButtonMorph(Morph)>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt: 
4 July 2011 12:24:02 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAnswer(Object)>>halt
	Receiver: a FOAnswer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection()
		content: 	nil
		accepted: 	nil


FOAnswer(FOPost)>>voteUp:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection()
		content: 	nil
		accepted: 	nil


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase announce: TestCaseEnded withResult: self.
	self addPass: aTestCase] in TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		timeStamp: 	2011-07-04T12:24:01+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase anno...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self]
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCase:
		startpc: 	58
		numArgs: 	0


TestResult>>runCase:
	Receiver: 0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		timeStamp: 	2011-07-04T12:24:01+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()


TestPost(TestCase)>>run:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aResult: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpect...etc...
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self run: result] in TestPost(TestCase)>>run
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self run: result]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>run
		startpc: 	45
		numArgs: 	0


TestPost(TestCase)>>run
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 expected failures, 0 failures, 0 errors, 0 unexpecte...etc...
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[target testSuite run] in OBCmdRunTests>>execute
	Receiver: an OBCmdRunTests
	Arguments and temporary variables: 

	Receiver's instance variables: 
		target: 	OBMethodNode<TestPost#testPostVotesHaveUniqueAuthor>
		requestor: 	an OBColumn(testPostVotesHaveUniqueAuthor)


BlockClosure>>ensure:
	Receiver: [target testSuite run]
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	OBCmdRunTests>>execute
		startpc: 	146
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: 16@16
	depth: 1
	fromArray: #(
		2r0
		2r11111111111111000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[target testSuite run]
		oldcursor: 	((CursorWithMask
	extent: 16@16
	depth: 1
	fromArray: #(
		2r0
		2r1...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	-1@ -1
		maskForm: 	Form(16x16x1)


OBShoutPlatform(OBMorphicPlatform)>>handleWaitRequest:
	Receiver: an OBShoutPlatform
	Arguments and temporary variables: 
		request: 	OBWaitRequest: 
	Receiver's instance variables: 
an OBShoutPlatform

OBWaitRequest>>handleWith:
	Receiver: OBWaitRequest: 
	Arguments and temporary variables: 
		anObject: 	an OBShoutPlatform
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	OBWaitRequest(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		block: 	[target testSuite run]


OBWaitRequest(OBInteractionRequest)>>defaultAction
	Receiver: OBWaitRequest: 
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	OBWaitRequest(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		block: 	[target testSuite run]


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	OBWaitRequest: 
	Receiver's instance variables: 
nil

MethodContext(ContextPart)>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	OBWaitRequest: 
		val: 	nil
	Receiver's instance variables: 
		sender: 	PasteUpMorph>>becomeActiveDuring:
		pc: 	17
		stackp: 	3
		method: 	(BlockClosure>>#on:do: "a CompiledMethod(88866816)")
		closureOrNil: 	nil
		receiver: 	[aBlock value]


OBWaitRequest(Exception)>>signal
	Receiver: OBWaitRequest: 
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signalContext: 	OBWaitRequest(Exception)>>signal
		handlerContext: 	nil
		outerContext: 	nil
		block: 	[target testSuite run]


OBWaitRequest class>>block:
	Receiver: OBWaitRequest
	Arguments and temporary variables: 
		aBlock: 	[target testSuite run]
	Receiver's instance variables: 
		superclass: 	OBInteractionRequest
		methodDict: 	a MethodDictionary(#block->(OBWaitRequest>>#block "a CompiledMethod...etc...
		format: 	142
		instanceVariables: 	#('block')
		organization: 	('accessing' block block:)
('dispatching' handleWith:)

		subclasses: 	nil
		name: 	#OBWaitRequest
		classPool: 	nil
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'OmniBrowser-Notifications'
		traitComposition: 	{}
		localSelectors: 	nil


OBCmdRunTests>>execute
	Receiver: an OBCmdRunTests
	Arguments and temporary variables: 
		result: 	nil
		defect: 	nil
	Receiver's instance variables: 
		target: 	OBMethodNode<TestPost#testPostVotesHaveUniqueAuthor>
		requestor: 	an OBColumn(testPostVotesHaveUniqueAuthor)


OBCmdRunTests(OBCommand)>>perform:orSendTo:
	Receiver: an OBCmdRunTests
	Arguments and temporary variables: 
		aSelector: 	#execute
		anObject: 	an OBPluggableListMorph(223608832)
	Receiver's instance variables: 
		target: 	OBMethodNode<TestPost#testPostVotesHaveUniqueAuthor>
		requestor: 	an OBColumn(testPostVotesHaveUniqueAuthor)


[| selArgCount | (selArgCount := selector numArgs) = 0
		ifTrue: [target perform: selector]
		ifFalse: [selArgCount = arguments size
				ifTrue: [target perform: selector withArguments: arguments]
				ifFalse: [target
						perform: selector
						withArguments: (arguments copyWith: evt)]]] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(635174912)'Run Test'
	Arguments and temporary variables: 
		evt: 	[782@512 mouseUp 3157724 nil]
		selArgCount: 	2
	Receiver's instance variables: 
		bounds: 	725@510 corner: 962@524
		owner: 	a MenuMorph(236978176)
		submorphs: 	#()
		fullBounds: 	725@510 corner: 962@524
		color: 	Color black
		extension: 	a MorphExtension (637796352)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Run Test'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	an OBCmdRunTests
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#execute an OBPluggableListMorph(223608832))
		icon: 	Form(16x1x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'cmd+t'


BlockClosure>>ensure:
	Receiver: [| selArgCount | (selArgCount := selector numArgs) = 0
		ifTrue: [target perform: selector...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	132
		numArgs: 	0


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: 16@16
	depth: 1
	fromArray: #(
		2r0
		2r10000000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[| selArgCount | (selArgCount := selector numArgs) = 0
		ifTrue: [targe...etc...
		oldcursor: 	((CursorWithMask
	extent: 16@16
	depth: 1
	fromArray: #(
		2r0
		2r1...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	-1@ -1
		maskForm: 	Form(16x16x1)


ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a ToggleMenuItemMorph(635174912)'Run Test'
	Arguments and temporary variables: 
		evt: 	[782@512 mouseUp 3157724 nil]
		w: 	a PasteUpMorph(425197568) [world]
	Receiver's instance variables: 
		bounds: 	725@510 corner: 962@524
		owner: 	a MenuMorph(236978176)
		submorphs: 	#()
		fullBounds: 	725@510 corner: 962@524
		color: 	Color black
		extension: 	a MorphExtension (637796352)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Run Test'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	an OBCmdRunTests
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#execute an OBPluggableListMorph(223608832))
		icon: 	Form(16x1x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'cmd+t'


ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a ToggleMenuItemMorph(635174912)'Run Test'
	Arguments and temporary variables: 
		evt: 	[782@512 mouseUp 3157724 nil]
	Receiver's instance variables: 
		bounds: 	725@510 corner: 962@524
		owner: 	a MenuMorph(236978176)
		submorphs: 	#()
		fullBounds: 	725@510 corner: 962@524
		color: 	Color black
		extension: 	a MorphExtension (637796352)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Run Test'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	an OBCmdRunTests
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#execute an OBPluggableListMorph(223608832))
		icon: 	Form(16x1x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'cmd+t'


ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a ToggleMenuItemMorph(635174912)'Run Test'
	Arguments and temporary variables: 
		anEvent: 	[782@512 mouseUp 3157724 nil]
	Receiver's instance variables: 
		bounds: 	725@510 corner: 962@524
		owner: 	a MenuMorph(236978176)
		submorphs: 	#()
		fullBounds: 	725@510 corner: 962@524
		color: 	Color black
		extension: 	a MorphExtension (637796352)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Run Test'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	an OBCmdRunTests
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#execute an OBPluggableListMorph(223608832))
		icon: 	Form(16x1x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'cmd+t'


MouseButtonEvent>>sentTo:
	Receiver: [782@512 mouseUp 3157724 nil]
	Arguments and temporary variables: 
		anObject: 	a ToggleMenuItemMorph(635174912)'Run Test'
	Receiver's instance variables: 
		timeStamp: 	3157724
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	782@512
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


ToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a ToggleMenuItemMorph(635174912)'Run Test'
	Arguments and temporary variables: 
		anEvent: 	[782@512 mouseUp 3157724 nil]
	Receiver's instance variables: 
		bounds: 	725@510 corner: 962@524
		owner: 	a MenuMorph(236978176)
		submorphs: 	#()
		fullBounds: 	725@510 corner: 962@524
		color: 	Color black
		extension: 	a MorphExtension (637796352)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Run Test'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	an OBCmdRunTests
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#execute an OBPluggableListMorph(223608832))
		icon: 	Form(16x1x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'cmd+t'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[782@512 mouseUp 3157724 nil]
		aMorph: 	a ToggleMenuItemMorph(635174912)'Run Test'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[782@512 mouseUp 3157724 nil]
		aMorph: 	a ToggleMenuItemMorph(635174912)'Run Test'
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


ToggleMenuItemMorph(Morph)>>processEvent:using:
	Receiver: a ToggleMenuItemMorph(635174912)'Run Test'
	Arguments and temporary variables: 
		anEvent: 	[782@512 mouseUp 3157724 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	725@510 corner: 962@524
		owner: 	a MenuMorph(236978176)
		submorphs: 	#()
		fullBounds: 	725@510 corner: 962@524
		color: 	Color black
		extension: 	a MorphExtension (637796352)
		font: 	a StrikeFont(Bitmap DejaVu Sans 9 14)
		emphasis: 	0
		contents: 	'Run Test'
		hasFocus: 	false
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	an OBCmdRunTests
		selector: 	#perform:orSendTo:
		arguments: 	an Array(#execute an OBPluggableListMorph(223608832))
		icon: 	Form(16x1x8)
		getStateSelector: 	nil
		enablementSelector: 	nil
		keyText: 	'cmd+t'


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[782@512 mouseUp 3157724 nil]
		aMorph: 	a MenuMorph(236978176)
		localEvt: 	[782@512 mouseUp 3157724 nil]
		index: 	18
		child: 	a ToggleMenuItemMorph(635174912)'Run Test'
		morphs: 	an Array(a ToggleMenuItemMorph(622067712)'File out' a ToggleMenuItemMor...etc...
		inside: 	false
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[782@512 mouseUp 3157724 nil]
		aMorph: 	a MenuMorph(236978176)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:



--- The full stack ---
FOAnswer(Object)>>halt
FOAnswer(FOPost)>>voteUp:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCase.
	aTestCase announce: TestCaseEnded withResult: self.
	self addPass: aTestCase] in TestResult>>runCase:
BlockClosure>>on:do:
TestResult>>runCase:
TestPost(TestCase)>>run:
[self run: result] in TestPost(TestCase)>>run
BlockClosure>>ensure:
TestPost(TestCase)>>run
[target testSuite run] in OBCmdRunTests>>execute
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
OBShoutPlatform(OBMorphicPlatform)>>handleWaitRequest:
OBWaitRequest>>handleWith:
OBWaitRequest(OBInteractionRequest)>>defaultAction
UndefinedObject>>handleSignal:
MethodContext(ContextPart)>>handleSignal:
OBWaitRequest(Exception)>>signal
OBWaitRequest class>>block:
OBCmdRunTests>>execute
OBCmdRunTests(OBCommand)>>perform:orSendTo:
[| selArgCount | (selArgCount := selector numArgs) = 0
		ifTrue: [target perform: selector]
		ifFalse: [selArgCount = arguments size
				ifTrue: [target perform: selector withArguments: arguments]
				ifFalse: [target
						perform: selector
						withArguments: (arguments copyWith: evt)]]] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:28:19 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[932@261 mouseUp 3414824 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [932@261 mouseUp 3414824 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	3414824
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	932@261
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[932@261 mouseUp 3414824 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	932@261 corner: 948@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	932@261 corner: 948@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207618048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[932@261 mouseUp 3414824 nil]
		targetOffset: 	201@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3414824 932 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(229376000) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[932@261 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(229376000) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	932@261 corner: 948@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	932@261 corner: 948@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207618048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[932@261 mouseUp 3414824 nil]
		targetOffset: 	201@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3414824 932 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	932@261 corner: 948@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	932@261 corner: 948@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207618048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[932@261 mouseUp 3414824 nil]
		targetOffset: 	201@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3414824 932 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
	Receiver's instance variables: 
		bounds: 	932@261 corner: 948@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	932@261 corner: 948@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207618048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[932@261 mouseUp 3414824 nil]
		targetOffset: 	201@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3414824 932 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[932@261 mouseUp 3414824 nil]
		evt: 	[932@261 mouseUp 3414824 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	932@261 corner: 948@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	932@261 corner: 948@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207618048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[932@261 mouseUp 3414824 nil]
		targetOffset: 	201@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3414824 932 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[932@261 mouseUp 3414824 nil]
		evtBuf: 	#(1 3414824 932 261 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	932@261 corner: 948@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	932@261 corner: 948@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207618048)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[932@261 mouseUp 3414824 nil]
		targetOffset: 	201@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3414824 932 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(632291328))(an Ove...etc...
		lastStepTime: 	3414822
		lastStepMessage: 	nil
		lastCycleTime: 	3414864
		alarms: 	a Heap()
		lastAlarmTime: 	3414822
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:28:21 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[863@259 mouseUp 3417208 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [863@259 mouseUp 3417208 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	3417208
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	863@259
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[863@259 mouseUp 3417208 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	863@259 corner: 879@275
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	863@259 corner: 879@275
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207093760)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[863@259 mouseUp 3417208 nil]
		targetOffset: 	132@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3417208 863 259 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(215220224) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[863@259 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(215220224) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	863@259 corner: 879@275
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	863@259 corner: 879@275
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207093760)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[863@259 mouseUp 3417208 nil]
		targetOffset: 	132@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3417208 863 259 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	863@259 corner: 879@275
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	863@259 corner: 879@275
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207093760)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[863@259 mouseUp 3417208 nil]
		targetOffset: 	132@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3417208 863 259 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
	Receiver's instance variables: 
		bounds: 	863@259 corner: 879@275
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	863@259 corner: 879@275
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207093760)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[863@259 mouseUp 3417208 nil]
		targetOffset: 	132@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3417208 863 259 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[863@259 mouseUp 3417208 nil]
		evt: 	[863@259 mouseUp 3417208 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	863@259 corner: 879@275
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	863@259 corner: 879@275
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207093760)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[863@259 mouseUp 3417208 nil]
		targetOffset: 	132@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3417208 863 259 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[863@259 mouseUp 3417208 nil]
		evtBuf: 	#(1 3417208 863 259 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	863@259 corner: 879@275
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	863@259 corner: 879@275
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(207093760)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[863@259 mouseUp 3417208 nil]
		targetOffset: 	132@4
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3417208 863 259 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(81...etc...
		lastStepTime: 	3417200
		lastStepMessage: 	nil
		lastCycleTime: 	3417242
		alarms: 	a Heap()
		lastAlarmTime: 	3417200
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 12:28:23 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487235295
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[783@260 mouseUp 3419370 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [783@260 mouseUp 3419370 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	3419370
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	783@260
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[783@260 mouseUp 3419370 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	783@260 corner: 799@276
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	783@260 corner: 799@276
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(969408512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[783@260 mouseUp 3419370 nil]
		targetOffset: 	52@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3419370 783 260 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(991166464) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[783@260 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(991166464) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	783@260 corner: 799@276
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	783@260 corner: 799@276
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(969408512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[783@260 mouseUp 3419370 nil]
		targetOffset: 	52@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3419370 783 260 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	783@260 corner: 799@276
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	783@260 corner: 799@276
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(969408512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[783@260 mouseUp 3419370 nil]
		targetOffset: 	52@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3419370 783 260 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
	Receiver's instance variables: 
		bounds: 	783@260 corner: 799@276
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	783@260 corner: 799@276
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(969408512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[783@260 mouseUp 3419370 nil]
		targetOffset: 	52@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3419370 783 260 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[783@260 mouseUp 3419370 nil]
		evt: 	[783@260 mouseUp 3419370 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	783@260 corner: 799@276
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	783@260 corner: 799@276
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(969408512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[783@260 mouseUp 3419370 nil]
		targetOffset: 	52@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3419370 783 260 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[783@260 mouseUp 3419370 nil]
		evtBuf: 	#(1 3419370 783 260 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	783@260 corner: 799@276
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	783@260 corner: 799@276
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(969408512)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[783@260 mouseUp 3419370 nil]
		targetOffset: 	52@5
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 3419370 783 260 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PreDebugWindow(991166464))(a PreDebu...etc...
		lastStepTime: 	3419352
		lastStepMessage: 	nil
		lastCycleTime: 	3419392
		alarms: 	a Heap()
		lastAlarmTime: 	3419352
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 1:29:21 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[908@261 mouseUp 7077130 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [908@261 mouseUp 7077130 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	7077130
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	908@261
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[908@261 mouseUp 7077130 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	908@261 corner: 924@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	908@261 corner: 924@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1048313856)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[908@261 mouseUp 7077130 nil]
		targetOffset: 	177@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7077130 908 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(1056440320) a Pl...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[908@261 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(1056440320) a Pl...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	908@261 corner: 924@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	908@261 corner: 924@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1048313856)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[908@261 mouseUp 7077130 nil]
		targetOffset: 	177@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7077130 908 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	908@261 corner: 924@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	908@261 corner: 924@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1048313856)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[908@261 mouseUp 7077130 nil]
		targetOffset: 	177@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7077130 908 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
	Receiver's instance variables: 
		bounds: 	908@261 corner: 924@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	908@261 corner: 924@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1048313856)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[908@261 mouseUp 7077130 nil]
		targetOffset: 	177@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7077130 908 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[908@261 mouseUp 7077130 nil]
		evt: 	[908@261 mouseUp 7077130 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	908@261 corner: 924@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	908@261 corner: 924@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1048313856)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[908@261 mouseUp 7077130 nil]
		targetOffset: 	177@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7077130 908 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[908@261 mouseUp 7077130 nil]
		evtBuf: 	#(1 7077130 908 261 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	908@261 corner: 924@277
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	908@261 corner: 924@277
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(1048313856)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[908@261 mouseUp 7077130 nil]
		targetOffset: 	177@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7077130 908 261 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(737148928))(an Ove...etc...
		lastStepTime: 	7077120
		lastStepMessage: 	nil
		lastCycleTime: 	7077160
		alarms: 	a Heap()
		lastAlarmTime: 	7077120
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 1 but was 2.
4 July 2011 1:29:24 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 1 but was 2.'
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		expected: 	1
		actual: 	2
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		failedSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487238955
		result: 	8 run, 7 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[806@263 mouseUp 7080220 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [806@263 mouseUp 7080220 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	7080220
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	806@263
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[806@263 mouseUp 7080220 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	806@263 corner: 822@279
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	806@263 corner: 822@279
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(560463872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[806@263 mouseUp 7080220 nil]
		targetOffset: 	75@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7080220 806 263 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(582221824) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[806@263 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(582221824) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	806@263 corner: 822@279
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	806@263 corner: 822@279
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(560463872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[806@263 mouseUp 7080220 nil]
		targetOffset: 	75@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7080220 806 263 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	806@263 corner: 822@279
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	806@263 corner: 822@279
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(560463872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[806@263 mouseUp 7080220 nil]
		targetOffset: 	75@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7080220 806 263 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
	Receiver's instance variables: 
		bounds: 	806@263 corner: 822@279
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	806@263 corner: 822@279
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(560463872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[806@263 mouseUp 7080220 nil]
		targetOffset: 	75@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7080220 806 263 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[806@263 mouseUp 7080220 nil]
		evt: 	[806@263 mouseUp 7080220 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	806@263 corner: 822@279
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	806@263 corner: 822@279
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(560463872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[806@263 mouseUp 7080220 nil]
		targetOffset: 	75@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7080220 806 263 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[806@263 mouseUp 7080220 nil]
		evtBuf: 	#(1 7080220 806 263 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	806@263 corner: 822@279
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	806@263 corner: 822@279
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(560463872)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[806@263 mouseUp 7080220 nil]
		targetOffset: 	75@8
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7080220 806 263 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(81...etc...
		lastStepTime: 	7080214
		lastStepMessage: 	nil
		lastCycleTime: 	7080258
		alarms: 	a Heap()
		lastAlarmTime: 	7080214
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: OrderedCollection>>hasAuthor:
4 July 2011 1:40:42 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

OrderedCollection(Object)>>doesNotUnderstand: #hasAuthor:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aMessage: 	hasAuthor: a FOAuthor
		exception: 	MessageNotUnderstood: OrderedCollection>>hasAuthor:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	2


FOAnswer(FOPost)>>voteUp:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection()
		content: 	nil
		accepted: 	nil


TestPost>>testPostVoteSize
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteSize
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteSize


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVoteSize
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVoteSize
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVoteSize)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVoteSize nil nil nil nil nil nil nil...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVoteSize
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVoteSize
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVoteSize
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteSize
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVoteSize
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVoteSize
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		event: 	[831@458 mouseUp 7757994 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [831@458 mouseUp 7757994 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(815792128)
	Receiver's instance variables: 
		timeStamp: 	7757994
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	831@458
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
		aMorph: 	a PluggableListMorph(815792128)
		localEvt: 	[831@458 mouseUp 7757994 nil]
		index: 	2
		child: 	a TransformMorph(415236096)
		morphs: 	an Array(a TransformMorph(415236096))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
		aMorph: 	a PluggableListMorph(815792128)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
		focusHolder: 	a PluggableListMorph(815792128)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	831@458 corner: 847@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	831@458 corner: 847@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(526123008)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[831@458 mouseUp 7757994 nil]
		targetOffset: 	100@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7757994 831 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(547094528) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[831@458 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(547094528) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
		focusHolder: 	a PluggableListMorph(815792128)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	831@458 corner: 847@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	831@458 corner: 847@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(526123008)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[831@458 mouseUp 7757994 nil]
		targetOffset: 	100@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7757994 831 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
		focusHolder: 	a PluggableListMorph(815792128)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	831@458 corner: 847@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	831@458 corner: 847@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(526123008)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[831@458 mouseUp 7757994 nil]
		targetOffset: 	100@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7757994 831 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
	Receiver's instance variables: 
		bounds: 	831@458 corner: 847@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	831@458 corner: 847@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(526123008)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[831@458 mouseUp 7757994 nil]
		targetOffset: 	100@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7757994 831 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[831@458 mouseUp 7757994 nil]
		evt: 	[831@458 mouseUp 7757994 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	831@458 corner: 847@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	831@458 corner: 847@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(526123008)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[831@458 mouseUp 7757994 nil]
		targetOffset: 	100@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7757994 831 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[831@458 mouseUp 7757994 nil]
		evtBuf: 	#(1 7757994 831 458 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	831@458 corner: 847@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	831@458 corner: 847@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(526123008)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[831@458 mouseUp 7757994 nil]
		targetOffset: 	100@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7757994 831 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a PluggableThemedOverflowPanelMorph(81...etc...
		lastStepTime: 	7758010
		lastStepMessage: 	nil
		lastCycleTime: 	7758052
		alarms: 	a Heap()
		lastAlarmTime: 	7758010
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #hasAuthor:
FOAnswer(FOPost)>>voteUp:
TestPost>>testPostVoteSize
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOUpVote>>author
4 July 2011 1:41:37 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOUpVote(Object)>>doesNotUnderstand: #author
	Receiver: a FOUpVote
	Arguments and temporary variables: 
		aMessage: 	author
		exception: 	MessageNotUnderstood: FOUpVote>>author
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor


[:vote | vote author = anAuthor] in FOAnswer(FOPost)>>hasAuthor:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOUpVote
		vote: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	nil
		accepted: 	nil


[:each | 
(aBlock value: each)
		ifTrue: [^ true].
	nil] in OrderedCollection(Collection)>>anySatisfy:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	a FOUpVote
		each: 	[:vote | vote author = anAuthor]
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	[:each | 
(aBlock value: each)
		ifTrue: [^ true].
	nil]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


OrderedCollection(Collection)>>anySatisfy:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	[:vote | vote author = anAuthor]
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


OrderedCollection(Collection)>>contains:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	[:vote | vote author = anAuthor]
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


FOAnswer(FOPost)>>hasAuthor:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	nil
		accepted: 	nil


FOAnswer(FOPost)>>voteUp:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	nil
		accepted: 	nil


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	3
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVoteSize TestPost>>#testPostVoteValue Te...etc...
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239625
		result: 	8 run, 5 passes, 0 expected failures, 0 failures, 3 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anInteger: 	3
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		event: 	[985@496 mouseUp 7813308 nil]
		row: 	3
		mdr: 	3
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [985@496 mouseUp 7813308 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(815792128)
	Receiver's instance variables: 
		timeStamp: 	7813308
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	985@496
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
		aMorph: 	a PluggableListMorph(815792128)
		localEvt: 	[985@496 mouseUp 7813308 nil]
		index: 	2
		child: 	a TransformMorph(415236096)
		morphs: 	an Array(a TransformMorph(415236096))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
		aMorph: 	a PluggableListMorph(815792128)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVoteSize' 'TestPost>>#testPostVoteValue' 'TestPost>...etc...
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
		focusHolder: 	a PluggableListMorph(815792128)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	985@496 corner: 1001@512
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	985@496 corner: 1001@512
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181665792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[986@497 985@496 mouseMove 7813308 nil]
		targetOffset: 	255@45
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7813308 985 496 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(178257920) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[985@496 mouseOver nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(178257920) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[985@496 mouseUp 7813308 nil]
		focusHolder: 	a PluggableListMorph(815792128)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	985@496 corner: 1001@512
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	985@496 corner: 1001@512
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(181665792)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[986@497 985@496 mouseMove 7813308 nil]
		targetOffset: 	255@45
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7813308 985 496 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil



--- The full stack ---
FOUpVote(Object)>>doesNotUnderstand: #author
[:vote | vote author = anAuthor] in FOAnswer(FOPost)>>hasAuthor:
[:each | 
(aBlock value: each)
		ifTrue: [^ true].
	nil] in OrderedCollection(Collection)>>anySatisfy:
OrderedCollection>>do:
OrderedCollection(Collection)>>anySatisfy:
OrderedCollection(Collection)>>contains:
FOAnswer(FOPost)>>hasAuthor:
FOAnswer(FOPost)>>voteUp:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOUpVote>>author
4 July 2011 1:41:46 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOUpVote(Object)>>doesNotUnderstand: #author
	Receiver: a FOUpVote
	Arguments and temporary variables: 
		aMessage: 	author
		exception: 	MessageNotUnderstood: FOUpVote>>author
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor


[:vote | vote author = anAuthor] in FOAnswer(FOPost)>>hasAuthor:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOUpVote
		vote: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	nil
		accepted: 	nil


[:each | 
(aBlock value: each)
		ifTrue: [^ true].
	nil] in OrderedCollection(Collection)>>anySatisfy:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	a FOUpVote
		each: 	[:vote | vote author = anAuthor]
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	[:each | 
(aBlock value: each)
		ifTrue: [^ true].
	nil]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


OrderedCollection(Collection)>>anySatisfy:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	[:vote | vote author = anAuthor]
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


OrderedCollection(Collection)>>contains:
	Receiver: an OrderedCollection(a FOUpVote)
	Arguments and temporary variables: 
		aBlock: 	[:vote | vote author = anAuthor]
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOUpVote nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


FOAnswer(FOPost)>>hasAuthor:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	nil
		accepted: 	nil


FOAnswer(FOPost)>>voteUp:
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		anAuthor: 	a FOAuthor
	Receiver's instance variables: 
		author: 	nil
		votes: 	an OrderedCollection(a FOUpVote)
		content: 	nil
		accepted: 	nil


TestPost>>testPostVotesHaveUniqueAuthor
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 
		post: 	a FOAnswer
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVotesHaveUniqueAuthor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVotesHaveUniqueAuthor


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239704
		result: 	8 run, 7 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVotesHaveUniqueAuthor)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVotesHaveUniqueAuthor nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239704
		result: 	8 run, 7 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239704
		result: 	8 run, 7 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239704
		result: 	8 run, 7 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVotesHaveUniqueAuthor
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239704
		result: 	8 run, 7 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


TestRunner>>errorSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	4
		classesSelected: 	a Set(TestPost)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(TestPost>>#testPostVotesHaveUniqueAuthor)
		errorSelected: 	TestPost>>#testPostVotesHaveUniqueAuthor
		lastUpdate: 	3487239704
		result: 	8 run, 7 passes, 0 expected failures, 0 failures, 1 errors, 0 unexpecte...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		event: 	[878@458 mouseUp 7822370 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [878@458 mouseUp 7822370 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(815792128)
	Receiver's instance variables: 
		timeStamp: 	7822370
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	878@458
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
		aMorph: 	a PluggableListMorph(815792128)
		localEvt: 	[878@458 mouseUp 7822370 nil]
		index: 	2
		child: 	a TransformMorph(415236096)
		morphs: 	an Array(a TransformMorph(415236096))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
		aMorph: 	a PluggableListMorph(815792128)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(815792128)
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
	Receiver's instance variables: 
		bounds: 	731@452 corner: 1159@624
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(415236096))
		fullBounds: 	731@452 corner: 1159@624
		color: 	Color white
		extension: 	a MorphExtension (938999808) [locked]  [externalName = Error List ] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(822607872)
		scroller: 	a TransformMorph(415236096)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#errorMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(612368384)
		list: 	#('TestPost>>#testPostVotesHaveUniqueAuthor')
		getListSelector: 	#errorList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#errorSelected
		setIndexSelector: 	#errorSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(644612096)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
		focusHolder: 	a PluggableListMorph(815792128)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	878@458 corner: 894@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	878@458 corner: 894@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(614989824)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[878@458 mouseUp 7822370 nil]
		targetOffset: 	147@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7822370 878 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(394002432) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	false
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[878@458 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(394002432) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[878@458 mouseUp 7822370 nil]
		focusHolder: 	a PluggableListMorph(815792128)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	878@458 corner: 894@474
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	878@458 corner: 894@474
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(614989824)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[878@458 mouseUp 7822370 nil]
		targetOffset: 	147@6
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 7822370 878 458 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil



--- The full stack ---
FOUpVote(Object)>>doesNotUnderstand: #author
[:vote | vote author = anAuthor] in FOAnswer(FOPost)>>hasAuthor:
[:each | 
(aBlock value: each)
		ifTrue: [^ true].
	nil] in OrderedCollection(Collection)>>anySatisfy:
OrderedCollection>>do:
OrderedCollection(Collection)>>anySatisfy:
OrderedCollection(Collection)>>contains:
FOAnswer(FOPost)>>hasAuthor:
FOAnswer(FOPost)>>voteUp:
TestPost>>testPostVotesHaveUniqueAuthor
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 2 but was 0.
4 July 2011 2:10:19 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 2 but was 0.'
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		expected: 	2
		actual: 	0
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost>>testPostVoteValue
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVoteValue)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVoteValue nil nil nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[905@268 mouseUp 9534936 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [905@268 mouseUp 9534936 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	9534936
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	905@268
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[905@268 mouseUp 9534936 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	905@268 corner: 921@284
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	905@268 corner: 921@284
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(321126400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[905@268 mouseUp 9534936 nil]
		targetOffset: 	174@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9534936 905 268 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(342884352) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[905@268 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(342884352) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	905@268 corner: 921@284
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	905@268 corner: 921@284
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(321126400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[905@268 mouseUp 9534936 nil]
		targetOffset: 	174@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9534936 905 268 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	905@268 corner: 921@284
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	905@268 corner: 921@284
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(321126400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[905@268 mouseUp 9534936 nil]
		targetOffset: 	174@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9534936 905 268 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
	Receiver's instance variables: 
		bounds: 	905@268 corner: 921@284
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	905@268 corner: 921@284
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(321126400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[905@268 mouseUp 9534936 nil]
		targetOffset: 	174@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9534936 905 268 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[905@268 mouseUp 9534936 nil]
		evt: 	[905@268 mouseUp 9534936 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	905@268 corner: 921@284
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	905@268 corner: 921@284
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(321126400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[905@268 mouseUp 9534936 nil]
		targetOffset: 	174@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9534936 905 268 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[905@268 mouseUp 9534936 nil]
		evtBuf: 	#(1 9534936 905 268 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	905@268 corner: 921@284
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	905@268 corner: 921@284
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(321126400)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[905@268 mouseUp 9534936 nil]
		targetOffset: 	174@13
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9534936 905 268 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(737148928))(an Ove...etc...
		lastStepTime: 	9534924
		lastStepMessage: 	nil
		lastCycleTime: 	9534968
		alarms: 	a Heap()
		lastAlarmTime: 	9534924
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVoteValue
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Expected 2 but was 0.
4 July 2011 2:12:04 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

TestPost(TestCase)>>assert:description:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aString: 	'Expected 2 but was 0.'
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>assert:equals:
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		expected: 	2
		actual: 	0
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost>>testPostVoteValue
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 
		post: 	a FOPost
		author1: 	a FOAuthor
		author2: 	a FOAuthor
	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


TestPost(TestCase)>>performTest
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[self tearDown.
	self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


TestPost(TestCase)>>runCase
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


BlockClosure>>ensure:
	Receiver: [(self class selector: testSelector) runCase]
	Arguments and temporary variables: 
		aBlock: 	[TestResource resetResources: self resources]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestPost(TestCase)>>debug
		startpc: 	41
		numArgs: 	0


TestPost(TestCase)>>debug
	Receiver: TestPost>>#testPostVoteValue
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testPostVoteValue


[:each | each debug] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		each: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(TestPost>>#testPostVoteValue)
	Arguments and temporary variables: 
		aBlock: 	[:each | each debug]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil TestPost>>#testPostVoteValue nil nil nil nil nil nil ni...etc...
		firstIndex: 	3
		lastIndex: 	3


[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


BlockClosure>>ensure:
	Receiver: [aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSui...etc...
	Arguments and temporary variables: 
		aBlock: 	[self basicTearDownSuite: aTestSuite]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestRunner>>basicRunSuite:do:
		startpc: 	51
		numArgs: 	0


TestRunner>>basicRunSuite:do:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[:each | each debug]
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


TestRunner>>debug:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestCase: 	TestPost>>#testPostVoteValue
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


TestRunner>>failedSelected:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		categories: 	#(#'SUnit-Extensions' #'SUnit-Kernel' #'SUnit-Tests' #'SUnit-Utilit...etc...
		categoriesSelected: 	a Set(#'Forum-Tests')
		classes: 	{TestAnswer. TestAuthor. TestModel. TestPost. TestQuestion. TestTag}
		classIndex: 	0
		classesSelected: 	a Set()
		failedList: 	an Array(TestPost>>#testPostVoteValue)
		failedSelected: 	TestPost>>#testPostVoteValue
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3487241413
		result: 	20 run, 19 passes, 0 expected failures, 1 failures, 0 errors, 0 unexpec...etc...
		previousRun: 	nil


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>mouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		event: 	[869@264 mouseUp 9639800 nil]
		row: 	1
		mdr: 	1
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>handleMouseUp:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [869@264 mouseUp 9639800 nil]
	Arguments and temporary variables: 
		anObject: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		timeStamp: 	9639800
		source: 	a HandMorph(843055104)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	869@264
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


PluggableListMorph(Morph)>>handleEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
		aMorph: 	a PluggableListMorph(825491456)
		localEvt: 	[869@264 mouseUp 9639800 nil]
		index: 	2
		child: 	a TransformMorph(413925376)
		morphs: 	an Array(a TransformMorph(413925376))
		inside: 	true
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
		aMorph: 	a PluggableListMorph(825491456)
	Receiver's instance variables: 
		lastType: 	#mouseUp
		lastDispatch: 	#dispatchDefault:with:


PluggableListMorph(Morph)>>processEvent:using:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph(Morph)>>processEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


PluggableListMorph>>handleFocusEvent:
	Receiver: a PluggableListMorph(825491456)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
	Receiver's instance variables: 
		bounds: 	731@255 corner: 1159@448
		owner: 	a PluggableStandardWindow(1022885888)
		submorphs: 	an Array(a TransformMorph(413925376))
		fullBounds: 	731@255 corner: 1159@448
		color: 	Color white
		extension: 	a MorphExtension (938213376) [locked]  [externalName = Failure List ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.833 g: 0.833 b: 0.833)
		model: 	a TestRunner
		slotName: 	nil
		open: 	false
		scrollBar: 	a ScrollBar(832307200)
		scroller: 	a TransformMorph(413925376)
		retractableScrollBar: 	false
		scrollBarOnLeft: 	false
		getMenuSelector: 	#failureMenu:
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(624689152)
		list: 	#('TestPost>>#testPostVoteValue')
		getListSelector: 	#failedList
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#failedSelected
		setIndexSelector: 	#failedSelected:
		keystrokeActionSelector: 	nil
		autoDeselect: 	true
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(643301376)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil


[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	869@264 corner: 885@280
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	869@264 corner: 885@280
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(130547712)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[869@264 mouseUp 9639800 nil]
		targetOffset: 	138@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9639800 869 264 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[aBlock value] in PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(152305664) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


BlockClosure>>on:do:
	Receiver: [aBlock value]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[:ex | 
ActiveWorld := priorWorld.
	ActiveEvent := priorEvent.
	...etc...
		handlerActive: 	true
	Receiver's instance variables: 
		outerContext: 	PasteUpMorph>>becomeActiveDuring:
		startpc: 	67
		numArgs: 	0


PasteUpMorph>>becomeActiveDuring:
	Receiver: a PasteUpMorph(425197568) [world]
	Arguments and temporary variables: 
		aBlock: 	[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
		...etc...
		priorWorld: 	a PasteUpMorph(425197568) [world]
		priorHand: 	a HandMorph(843055104)
		priorEvent: 	[869@264 mouseOver red nil nil]
	Receiver's instance variables: 
		bounds: 	0@0 corner: 1224@722
		owner: 	nil
		submorphs: 	an Array(a TaskbarMorph(811335680) a PreDebugWindow(152305664) a Plu...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.191 g: 0.191 b: 0.191)
		extension: 	a MorphExtension (666632192) [eventHandler = an EventHandler]  [othe...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.03 g: 0.02 b: 0.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		w: 	a PasteUpMorph(425197568) [world]
		result: 	#(nil)
	Receiver's instance variables: 
		bounds: 	869@264 corner: 885@280
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	869@264 corner: 885@280
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(130547712)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[869@264 mouseUp 9639800 nil]
		targetOffset: 	138@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9639800 869 264 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
		focusHolder: 	a PluggableListMorph(825491456)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	869@264 corner: 885@280
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	869@264 corner: 885@280
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(130547712)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[869@264 mouseUp 9639800 nil]
		targetOffset: 	138@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9639800 869 264 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
	Receiver's instance variables: 
		bounds: 	869@264 corner: 885@280
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	869@264 corner: 885@280
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(130547712)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[869@264 mouseUp 9639800 nil]
		targetOffset: 	138@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9639800 869 264 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>handleEvent:
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		anEvent: 	[869@264 mouseUp 9639800 nil]
		evt: 	[869@264 mouseUp 9639800 nil]
		ofs: 	nil
	Receiver's instance variables: 
		bounds: 	869@264 corner: 885@280
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	869@264 corner: 885@280
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(130547712)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[869@264 mouseUp 9639800 nil]
		targetOffset: 	138@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9639800 869 264 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


HandMorph>>processEvents
	Receiver: a HandMorph(843055104)
	Arguments and temporary variables: 
		evt: 	[869@264 mouseUp 9639800 nil]
		evtBuf: 	#(1 9639800 869 264 0 0 0 1)
		type: 	1
		hadAny: 	false
	Receiver's instance variables: 
		bounds: 	869@264 corner: 885@280
		owner: 	a PasteUpMorph(425197568) [world]
		submorphs: 	#()
		fullBounds: 	869@264 corner: 885@280
		color: 	Color blue
		extension: 	a MorphExtension (141295616) [eventHandler = an EventHandler] 
		mouseFocus: 	nil
		keyboardFocus: 	a PluggableButtonMorph(130547712)
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[869@264 mouseUp 9639800 nil]
		targetOffset: 	138@9
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		userInitials: 	''
		lastEventBuffer: 	#(1 9639800 869 264 0 0 0 1)
		lastKeyScanCode: 	115
		combinedChar: 	nil


[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		h: 	a HandMorph(843055104)
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(843055104))
		viewBox: 	0@0 corner: 1224@722
		canvas: 	a FormCanvas on: DisplayScreen(1224x722x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> an OverflowRowMorph(737148928))(an Ove...etc...
		lastStepTime: 	9639788
		lastStepMessage: 	nil
		lastCycleTime: 	9639830
		alarms: 	a Heap()
		lastAlarmTime: 	9639788
		menuBuilder: 	a PragmaMenuBuilder


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(843055104))
	Arguments and temporary variables: 
		aBlock: 	[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil]
		index: 	1
		indexLimiT: 	1
	Receiver's instance variables: 
an Array(a HandMorph(843055104))


--- The full stack ---
TestPost(TestCase)>>assert:description:
TestPost(TestCase)>>assert:equals:
TestPost>>testPostVoteValue
TestPost(TestCase)>>performTest
[self setUp.
	self performTest] in TestPost(TestCase)>>runCase
BlockClosure>>ensure:
TestPost(TestCase)>>runCase
[(self class selector: testSelector) runCase] in TestPost(TestCase)>>debug
BlockClosure>>ensure:
TestPost(TestCase)>>debug
[:each | each debug] in TestRunner>>debugSuite:
OrderedCollection>>do:
[aTestSuite name isEmptyOrNil
		ifTrue: [aTestSuite tests do: aBlock]
		ifFalse: [aTestSuite tests do: aBlock displayingProgress: aTestSuite name]] in TestRunner>>basicRunSuite:do:
BlockClosure>>ensure:
TestRunner>>basicRunSuite:do:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ActiveHand := self.
	ActiveEvent := anEvent.
	result := focusHolder
				handleFocusEvent: (anEvent
						transformedBy: (focusHolder transformedFrom: self))] in HandMorph>>sendFocusEvent:to:clear:
[aBlock value] in PasteUpMorph>>becomeActiveDuring:
BlockClosure>>on:do:
PasteUpMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEvents
[:h | 
ActiveHand := h.
	h processEvents.
	ActiveHand := nil] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
PasteUpMorph>>doOneCycle
[[World doOneCycle.
	Processor yield.
	false] whileFalse.
	nil] in Project class>>spawnNewProcess
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "content" is nil
4 July 2011 2:41:19 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #content
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	content
		exception: 	MessageNotUnderstood: receiver of "content" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self render...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	60
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	76
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #content
[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "authorName" is nil
4 July 2011 2:41:55 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #authorName
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	authorName
		exception: 	MessageNotUnderstood: receiver of "authorName" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self render...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	60
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	76
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #authorName
[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "content" is nil
4 July 2011 2:42 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #content
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	content
		exception: 	MessageNotUnderstood: receiver of "content" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self render...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	60
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self render...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	60
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	76
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #content
[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "content" is nil
4 July 2011 2:42:06 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #content
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	content
		exception: 	MessageNotUnderstood: receiver of "content" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self render...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	60
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas text: answer content;
		 break;
		 text: answer authorName;
	...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	76
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #content
[canvas text: answer content;
		 break;
		 text: answer authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOViewQuestion>>contents
4 July 2011 3:06:09 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOViewQuestion(Object)>>doesNotUnderstand: #contents
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aMessage: 	contents
		exception: 	MessageNotUnderstood: FOViewQuestion>>contents
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WATextAreaTag(WAFormInputTag)>>on:of:
	Receiver: a WATextAreaTag
	Arguments and temporary variables: 
		aSelector: 	#contents
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('rows'->'auto' 'cols'->'auto')
		value: 	nil


[canvas label: 'Answer'.
	canvas textArea on: #contents of: self.
	canvas submitButton] in [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #contents of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas label: 'Answer'.
	canvas textArea on: #contents of: self.
	canvas submitButton]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea ...etc...
		startpc: 	75
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #contents of: self.
	ca...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #contents of: self.
	ca...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #contents of: self.
	ca...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WAFormTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WAFormTag(WABrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #contents of: self.
	ca...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #contents of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #contents of: self.
	...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	68
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	76
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext



--- The full stack ---
FOViewQuestion(Object)>>doesNotUnderstand: #contents
WATextAreaTag(WAFormInputTag)>>on:of:
[canvas label: 'Answer'.
	canvas textArea on: #contents of: self.
	canvas submitButton] in [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #contents of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #contents of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOViewQuestion>>ansWercontent
4 July 2011 3:15:55 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOViewQuestion(Object)>>doesNotUnderstand: #ansWercontent
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aMessage: 	ansWercontent
		exception: 	MessageNotUnderstood: FOViewQuestion>>ansWercontent
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WATextAreaTag(WAFormInputTag)>>on:of:
	Receiver: a WATextAreaTag
	Arguments and temporary variables: 
		aSelector: 	#ansWercontent
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('rows'->'auto' 'cols'->'auto')
		value: 	nil


[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self.
	canvas submitButton] in [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self.
	canvas submitButto...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea ...etc...
		startpc: 	75
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WAFormTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WAFormTag(WABrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: se...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	68
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	76
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext



--- The full stack ---
FOViewQuestion(Object)>>doesNotUnderstand: #ansWercontent
WATextAreaTag(WAFormInputTag)>>on:of:
[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self.
	canvas submitButton] in [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton]] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOViewQuestion>>ansWercontent
4 July 2011 3:18:28 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOViewQuestion(Object)>>doesNotUnderstand: #ansWercontent
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aMessage: 	ansWercontent
		exception: 	MessageNotUnderstood: FOViewQuestion>>ansWercontent
		resumeValue: 	nil
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WATextAreaTag(WAFormInputTag)>>on:of:
	Receiver: a WATextAreaTag
	Arguments and temporary variables: 
		aSelector: 	#ansWercontent
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('rows'->'auto' 'cols'->'auto')
		value: 	nil


[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self.
	canvas submitButton on: #postNewAnswer of: self] in [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton on: #postNewAnswer of: self]] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self.
	canvas submitButto...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea ...etc...
		startpc: 	79
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WAFormTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WAFormTag(WABrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton on: #postNewAnswer of: self]] in FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: se...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAddAnswerOn:
		startpc: 	72
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'addAnswer')


FOViewQuestion>>renderAddAnswerOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	76
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WATextAreaTag
		parentBrush: 	a WAFormTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext



--- The full stack ---
FOViewQuestion(Object)>>doesNotUnderstand: #ansWercontent
WATextAreaTag(WAFormInputTag)>>on:of:
[canvas label: 'Answer'.
	canvas textArea on: #ansWercontent of: self.
	canvas submitButton on: #postNewAnswer of: self] in [canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton on: #postNewAnswer of: self]] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
[canvas form
		with: [canvas label: 'Answer'.
			canvas textArea on: #ansWercontent of: self.
			canvas submitButton on: #postNewAnswer of: self]] in FOViewQuestion>>renderAddAnswerOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAddAnswerOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOQuestion>>hasAnswers
4 July 2011 3:37:01 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOQuestion(Object)>>doesNotUnderstand: #hasAnswers
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		aMessage: 	hasAnswers
		exception: 	MessageNotUnderstood: FOQuestion>>hasAnswers
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'Can someone vote on this question'
		answers: 	an OrderedCollection(a FOAnswer)
		title: 	'Help'
		tags: 	an OrderedCollection()
		comments: 	nil


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Jurre'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Jurre'


[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Jurre'


BlockClosure>>renderOn:
	Receiver: [self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBo...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderContentOn:
		startpc: 	44
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
	Receiver: a WAFormTag
	Arguments and temporary variables: 
		anObject: 	[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('accept-charset'->'utf-8' 'method'->'post' 'acti...etc...
		defaultAction: 	nil


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WAFormTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
FOQuestion(Object)>>doesNotUnderstand: #hasAnswers
FOViewQuestion>>renderAnswersOn:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOQuestion>>nrOfAnswersString
4 July 2011 3:39:48 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOQuestion(Object)>>doesNotUnderstand: #nrOfAnswersString
	Receiver: a FOQuestion
	Arguments and temporary variables: 
		aMessage: 	nrOfAnswersString
		exception: 	MessageNotUnderstood: FOQuestion>>nrOfAnswersString
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'Can someone vote on this question'
		answers: 	an OrderedCollection(a FOAnswer)
		title: 	'Help'
		tags: 	an OrderedCollection()
		comments: 	nil


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WAHeadingTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderingGuide(WAPresenterGuide)>>visit:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAPainter)>>renderWithContext:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderContext: 	a WARenderContext
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


FOViewQuestion(WAPainter)>>renderOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
	Receiver: a FOAgileOverflow
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a WAToolDecoration
		pages: 	an OrderedCollection(a FOHome a FOAskQuestion a FOAskQuestion2 a FOAllQu...etc...
		currentPage: 	a FOViewQuestion
		homepage: 	nil
		loginName: 	'Jurre'


BlockClosure>>renderOn:
	Receiver: [canvas render: self currentPage]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOAgileOverflow>>renderMainOn:
		startpc: 	73
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas render: self currentPage]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WAFormTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'mainleft')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag



--- The full stack ---
FOQuestion(Object)>>doesNotUnderstand: #nrOfAnswersString
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>title
4 July 2011 3:42:50 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAnswer(Object)>>doesNotUnderstand: #title
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	title
		exception: 	MessageNotUnderstood: FOAnswer>>title
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	nil
		content: 	'Click the logout button'
		accepted: 	nil


[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn: canvas.
	canvas tex...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #title
[canvas heading: anAnswer title.
	self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>votesTotal
4 July 2011 3:43:18 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAnswer(Object)>>doesNotUnderstand: #votesTotal
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	votesTotal
		exception: 	MessageNotUnderstood: FOAnswer>>votesTotal
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	nil
		content: 	'Click the logout button'
		accepted: 	nil


[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer votesTotal;
		 break.
	canvas anchor
		callback: [anAnswer downvote];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canva...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:votesOn:
		startpc: 	81
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'votes')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'votes')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'votes')


FOViewQuestion>>renderAnswer:votesOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
	...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	61
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #votesTotal
[canvas anchor
		callback: [anAnswer upvote];
		
		with: [canvas html: '&#x25b2;'].
	canvas break.
	canvas text: anAnswer votesTotal;
		 break.
	canvas anchor
		callback: [anAnswer downvote];
		
		with: [canvas html: '&#x25bc;']] in FOViewQuestion>>renderAnswer:votesOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:votesOn:
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: FOAnswer>>contents
4 July 2011 3:44:33 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

FOAnswer(Object)>>doesNotUnderstand: #contents
	Receiver: a FOAnswer
	Arguments and temporary variables: 
		aMessage: 	contents
		exception: 	MessageNotUnderstood: FOAnswer>>contents
		resumeValue: 	nil
	Receiver's instance variables: 
		author: 	a FOAuthor
		votes: 	an OrderedCollection()
		content: 	'Click the logout button'
		accepted: 	nil


[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
	...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	61
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	3
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer nil nil nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	3


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	nil
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor>>visitPainter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
		renderer: 	a WARenderCanvas
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderVisitor(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderVisitor
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderVisitor(WAVisitor)>>visit:
	Receiver: a WARenderVisitor
	Arguments and temporary variables: 
		anObject: 	a FOViewQuestion
	Receiver's instance variables: 
		renderContext: 	a WARenderContext


WARenderingGuide(WAPresenterGuide)>>visitPainter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPainter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitPresenter:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aPresenter: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


WARenderingGuide(WAPainterVisitor)>>visitComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>accept:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'


WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
	Receiver: a WARenderingGuide
	Arguments and temporary variables: 
		aComponent: 	a FOViewQuestion
	Receiver's instance variables: 
		client: 	a WARenderVisitor


FOViewQuestion(WAComponent)>>acceptDecorated:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		aVisitor: 	a WARenderingGuide
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'Click the logout button'



--- The full stack ---
FOAnswer(Object)>>doesNotUnderstand: #contents
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer contents;
		 break;
		 text: anAnswer author] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
FOViewQuestion>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "userName" is nil
4 July 2011 4:05:08 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #userName
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	userName
		exception: 	MessageNotUnderstood: receiver of "userName" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'ctrl+f4'


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	65
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'ctrl+f4'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'ctrl+f4'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	5


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'ctrl+f4'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'ctrl+f4'


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'ctrl+f4'


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	80
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'ctrl+f4'



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #userName
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "userName" is nil
4 July 2011 4:06:40 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #userName
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	userName
		exception: 	MessageNotUnderstood: receiver of "userName" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	''


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	65
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	''


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	''


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	5


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	''


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	''


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	''


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	80
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	''



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #userName
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "userName" is nil
4 July 2011 4:07:47 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #userName
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	userName
		exception: 	MessageNotUnderstood: receiver of "userName" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	65
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	5


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	80
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #userName
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "userName" is nil
4 July 2011 4:08:54 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #userName
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	userName
		exception: 	MessageNotUnderstood: receiver of "userName" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	65
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer nil nil nil nil nil)
		firstIndex: 	3
		lastIndex: 	5


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	80
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #userName
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "userName" is nil
4 July 2011 4:11:06 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #userName
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	userName
		exception: 	MessageNotUnderstood: receiver of "userName" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'mehhhhh'


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	65
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'mehhhhh'


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'mehhhhh'


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer ...etc...
		firstIndex: 	3
		lastIndex: 	8


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'mehhhhh'


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'mehhhhh'


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'mehhhhh'


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	80
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	'mehhhhh'



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #userName
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MessageNotUnderstood: receiver of "userName" is nil
4 July 2011 4:13:33 pm

VM: unix - i686 - linux-gnu - Croquet Closure Cog VM [CoInterpreter VMMaker-oscog.51]
Image: Pharo1.2.2 [Latest update: #12353]

SecurityManager state:
Restricted: false
FileAccess: true
SocketAccess: true
Working Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources
Trusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/secure
Untrusted Dir /home/jurre/smalltalk/Seaside.app/Contents/Resources/My Squeak

UndefinedObject(Object)>>doesNotUnderstand: #userName
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	userName
		exception: 	MessageNotUnderstood: receiver of "userName" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswer:on:
		startpc: 	65
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer ...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answer')


FOViewQuestion>>renderAnswer:on:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		anAnswer: 	a FOAnswer
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a FOAnswer
		answer: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


OrderedCollection>>do:
	Receiver: an OrderedCollection(a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer)
	Arguments and temporary variables: 
		aBlock: 	[:answer | self renderAnswer: answer on: canvas]
		index: 	5
	Receiver's instance variables: 
		array: 	an Array(nil nil a FOAnswer a FOAnswer a FOAnswer a FOAnswer a FOAnswer ...etc...
		firstIndex: 	3
		lastIndex: 	8


[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:a...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderAnswersOn:
		startpc: 	69
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading level: 1;
		 with: question nrOfAnswersString.
	quest...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	a WADivTag
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-answers')


FOViewQuestion>>renderAnswersOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil


BlockClosure>>renderOn:
	Receiver: [canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question conte...etc...
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	FOViewQuestion>>renderContentOn:
		startpc: 	80
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


BlockClosure>>renderOn:
	Receiver: [self before.
	canvas render: anObject.
	self after]
	Arguments and temporary variables: 
		aRenderer: 	a WARenderCanvas
	Receiver's instance variables: 
		outerContext: 	WADivTag(WATagBrush)>>with:
		startpc: 	50
		numArgs: 	0


WARenderCanvas(WARenderer)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>render:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		anObject: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WARenderCanvas(WACanvas)>>nest:
	Receiver: a WARenderCanvas
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		context: 	a WARenderContext
		lastId: 	nil
		currentBrush: 	a WABreakTag
		parentBrush: 	a WADivTag


WADivTag(WABrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		aBlock: 	[self before.
	canvas render: anObject.
	self after]
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


WADivTag(WATagBrush)>>with:
	Receiver: a WADivTag
	Arguments and temporary variables: 
		anObject: 	[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas...etc...
	Receiver's instance variables: 
		canvas: 	a WARenderCanvas
		parent: 	nil
		closed: 	false
		attributes: 	a WAHtmlAttributes('class'->'view-question')


FOViewQuestion>>renderContentOn:
	Receiver: a FOViewQuestion
	Arguments and temporary variables: 
		canvas: 	a WARenderCanvas
	Receiver's instance variables: 
		decoration: 	a WAValueHolder contents: a FOViewQuestion
		question: 	a FOQuestion
		answer: 	nil
		content: 	nil



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #userName
[self renderAnswer: anAnswer votesOn: canvas.
	canvas text: anAnswer content;
		 break;
		 text: anAnswer author userName] in FOViewQuestion>>renderAnswer:on:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswer:on:
[:answer | self renderAnswer: answer on: canvas] in [canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
OrderedCollection>>do:
[canvas heading level: 1;
		 with: question nrOfAnswersString.
	question answers
		do: [:answer | self renderAnswer: answer on: canvas]] in FOViewQuestion>>renderAnswersOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderAnswersOn:
[canvas heading: question title.
	self renderVotesOn: canvas.
	canvas text: question content;
		 break;
		 text: question tagString;
		 break;
		 text: question authorName;
		 break.
	self renderAnswersOn: canvas.
	self renderAddAnswerOn: canvas] in FOViewQuestion>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOViewQuestion>>renderContentOn:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOViewQuestion(WAComponent)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOViewQuestion(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOViewQuestion(WAPainter)>>renderWithContext:
FOViewQuestion(WAPainter)>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[canvas render: self currentPage] in FOAgileOverflow>>renderMainOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WADivTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WADivTag(WABrush)>>with:
WADivTag(WATagBrush)>>with:
FOAgileOverflow>>renderMainOn:
[self renderTopOn: canvas;
		 renderHeaderOn: canvas;
		 renderMainOn: canvas;
		 renderBottomOn: canvas] in FOAgileOverflow>>renderContentOn:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
[self before.
	canvas render: anObject.
	self after] in WAFormTag(WATagBrush)>>with:
BlockClosure>>renderOn:
WARenderCanvas(WARenderer)>>render:
WARenderCanvas(WACanvas)>>render:
WARenderCanvas(WACanvas)>>nest:
WAFormTag(WABrush)>>with:
WAFormTag(WATagBrush)>>with:
FOAgileOverflow>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitComponent:
FOAgileOverflow(WAComponent)>>accept:
FOAgileOverflow(WAPresenter)>>renderUndecoratedWithContext:
WAToolDecoration(WADecoration)>>renderNextOn:
WAToolDecoration>>renderChildOn:
WAToolDecoration>>renderContentOn:
WARenderVisitor>>visitPainter:
WARenderVisitor(WAPainterVisitor)>>visitPresenter:
WARenderVisitor(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderVisitor(WAVisitor)>>visit:
WARenderingGuide(WAPresenterGuide)>>visitPainter:
WARenderingGuide(WAPainterVisitor)>>visitPresenter:
WARenderingGuide(WAPainterVisitor)>>visitDecoration:
WAToolDecoration(WADecoration)>>accept:
WARenderingGuide(WAPainterVisitor)>>visitDecorationsOfComponent:
FOAgileOverflow(WAComponent)>>acceptDecorated:
WARenderingGuide(WAPresenterGuide)>>visit:
FOAgileOverflow(WAPainter)>>renderWithContext:
WARenderPhaseContinuation>>processRendering:
[:response | self processRendering: response] in WARenderPhaseContinuation>>handleRequest
WARequestContext>>respond:
WARenderPhaseContinuation(WASessionContinuation)>>respond:
WARenderPhaseContinuation>>handleRequest
[self handleRequest] in WARenderPhaseContinuation(WASessionContinuation)>>basicValue
BlockClosure>>on:do:
WARenderPhaseContinuation(WASessionContinuation)>>withUnregisteredHandlerDo:
WARenderPhaseContinuation(WASessionContinuation)>>basicValue
WARenderPhaseContinuation(WASessionContinuation)>>value
FOSession(WASession)>>handleFiltered:
WATimingToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WATimingToolFilter>>handleFiltered:
BlockClosure>>ensure:
WATimingToolFilter>>handleFiltered:
WADeprecatedToolFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WADeprecatedToolFilter>>handleFiltered:
BlockClosure>>on:do:
WADeprecatedToolFilter>>handleFiltered:
WAMutualExclusionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAMutualExclusionFilter>>handleFiltered:
BlockClosure>>ensure:
[owner := process.
	aBlock
		ensure: [owner := nil]] in WAMutex>>critical:
[caught := true.
	self wait.
	blockValue := mutuallyExcludedBlock value] in Semaphore>>critical:
BlockClosure>>ensure:
Semaphore>>critical:
WAMutex>>critical:
WAMutualExclusionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in FOSession(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
FOSession(WARequestHandler)>>handle:
WAApplication(WARegistry)>>dispatch:to:
WAApplication(WARegistry)>>handleKeyed:with:
WAApplication(WARegistry)>>handleFiltered:
WAApplication>>handleFiltered:
WAExceptionFilter(WARequestFilter)>>handleFiltered:
[super handleFiltered: aRequestContext] in WAExceptionFilter>>handleFiltered:
BlockClosure>>on:do:
WAWalkbackErrorHandler(WAExceptionHandler)>>handleExceptionsDuring:
WAWalkbackErrorHandler class(WAExceptionHandler class)>>handleExceptionsDuring:context:
WAExceptionFilter>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WAApplication(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WAApplication(WARequestHandler)>>handle:
WADispatcher>>handleFiltered:named:
WADispatcher>>handleFiltered:
[self filter handleFiltered: aRequestContext] in WADispatcher(WARequestHandler)>>handle:
BlockClosure>>on:do:
WACurrentRequestContext class(WADynamicVariable class)>>use:during:
[WACurrentRequestContext use: self during: aBlock] in WARequestContext>>push:while:
BlockClosure>>ensure:
WARequestContext>>push:while:
WADispatcher(WARequestHandler)>>handle:
[self requestHandler handle: aRequestContext] in WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
BlockClosure>>on:do:
WAComancheAdaptor(WAServerAdaptor)>>handleRequest:
WAComancheAdaptor(WAServerAdaptor)>>handle:
[self handle: context;
		 responseFrom: context] in WAComancheAdaptor(WAServerAdaptor)>>process:
BlockClosure>>ensure:
WAComancheAdaptor(WAServerAdaptor)>>process:
WAComancheAdaptor>>processHttpRequest:
HttpService>>processHttpRequest:
[self target processHttpRequest: request] in HttpAdaptor>>dispatchRequest:
BlockClosure>>on:do:
HttpService>>handleDispatchErrorsIn:
HttpAdaptor>>dispatchRequest:
[[[request := self readRequest]
		on: Error
		do: [:ex | continue := false].
	continue
		ifTrue: [response := self dispatchRequest: request.
			self
				addConnectionHeaders: response
				request: request
				count: count.
			(self writeResponse: response for: request)
				ifFalse: [^ self].
			count := count + 1.
			continue := response isPersistent
						and: [count < limit]].
	continue] whileTrue.
	nil] in HttpAdaptor>>beginConversation
BlockClosure>>ensure:
HttpAdaptor>>beginConversation
HttpAdaptor class>>readAndWriteTo:service:
HttpAdaptor class>>readAndWriteToSocket:service:
HttpService>>serve:
[self serve: aSocket] in HttpService(TcpService)>>value:
[self value.
	Processor terminateActive] in BlockClosure>>newProcess
------------------------------------------------------------

